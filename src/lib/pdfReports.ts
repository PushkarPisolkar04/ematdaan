import { supabase } from './supabase';

export interface ElectionReport {
  id: string;
  name: string;
  description: string;
  startDate: string;
  endDate: string;
  totalVotes: number;
  totalRegistered: number;
  turnout: number;
  candidates: Array<{
    id: string;
    name: string;
    votes: number;
    percentage: number;
    position: number;
  }>;
  organization: {
    name: string;
    logo?: string;
  };
  generatedAt: string;
}

export interface VoteCertificate {
  voterId: string;
  voterName: string;
  electionName: string;
  electionId: string;
  voteTime: string;
  receiptId: string;
  candidateName: string;
  organizationName: string;
  certificateId: string;
}

// Generate PDF using jsPDF
const generatePDF = async (content: any, filename: string): Promise<void> => {
  // Dynamic import to avoid SSR issues
  const { jsPDF } = await import('jspdf');
  const doc = new jsPDF();

  // Set document properties
  doc.setProperties({
    title: filename,
    subject: 'E-Matdaan Election Report',
    author: 'E-Matdaan System',
    creator: 'E-Matdaan Voting Platform'
  });

  // Add content based on type
  if (content.type === 'election_report') {
    generateElectionReportPDF(doc, content.data);
  } else if (content.type === 'vote_certificate') {
    generateVoteCertificatePDF(doc, content.data);
  }

  // Save the PDF
  doc.save(filename);
};

const generateElectionReportPDF = (doc: any, report: ElectionReport) => {
  const pageWidth = doc.internal.pageSize.width;
  const margin = 20;
  let yPosition = 30;

  // Header
  doc.setFontSize(24);
  doc.setFont('helvetica', 'bold');
  doc.text('E-Matdaan Election Report', pageWidth / 2, yPosition, { align: 'center' });
  yPosition += 20;

  // Election Details
  doc.setFontSize(16);
  doc.setFont('helvetica', 'bold');
  doc.text('Election Details', margin, yPosition);
  yPosition += 15;

  doc.setFontSize(12);
  doc.setFont('helvetica', 'normal');
  doc.text(`Election Name: ${report.name}`, margin, yPosition);
  yPosition += 8;
  doc.text(`Description: ${report.description}`, margin, yPosition);
  yPosition += 8;
  doc.text(`Start Date: ${new Date(report.startDate).toLocaleDateString()}`, margin, yPosition);
  yPosition += 8;
  doc.text(`End Date: ${new Date(report.endDate).toLocaleDateString()}`, margin, yPosition);
  yPosition += 8;
  doc.text(`Organization: ${report.organization.name}`, margin, yPosition);
  yPosition += 15;

  // Statistics
  doc.setFontSize(16);
  doc.setFont('helvetica', 'bold');
  doc.text('Voting Statistics', margin, yPosition);
  yPosition += 15;

  doc.setFontSize(12);
  doc.setFont('helvetica', 'normal');
  doc.text(`Total Registered Voters: ${report.totalRegistered.toLocaleString()}`, margin, yPosition);
  yPosition += 8;
  doc.text(`Total Votes Cast: ${report.totalVotes.toLocaleString()}`, margin, yPosition);
  yPosition += 8;
  doc.text(`Voter Turnout: ${report.turnout.toFixed(2)}%`, margin, yPosition);
  yPosition += 15;

  // Results Table
  doc.setFontSize(16);
  doc.setFont('helvetica', 'bold');
  doc.text('Election Results', margin, yPosition);
  yPosition += 15;

  // Table headers
  const tableHeaders = ['Position', 'Candidate', 'Votes', 'Percentage'];
  const colWidths = [25, 80, 30, 35];
  let xPosition = margin;

  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  tableHeaders.forEach((header, index) => {
    doc.text(header, xPosition, yPosition);
    xPosition += colWidths[index];
  });
  yPosition += 8;

  // Table data
  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  report.candidates.forEach((candidate, index) => {
    // Check if we need a new page
    if (yPosition > 250) {
      doc.addPage();
      yPosition = 30;
    }

    xPosition = margin;
    doc.text(`${candidate.position}`, xPosition, yPosition);
    xPosition += colWidths[0];
    doc.text(candidate.name, xPosition, yPosition);
    xPosition += colWidths[1];
    doc.text(candidate.votes.toLocaleString(), xPosition, yPosition);
    xPosition += colWidths[2];
    doc.text(`${candidate.percentage.toFixed(2)}%`, xPosition, yPosition);
    yPosition += 8;
  });

  // Footer
  yPosition += 20;
  doc.setFontSize(10);
  doc.setFont('helvetica', 'italic');
  doc.text(`Report generated on ${new Date(report.generatedAt).toLocaleString()}`, margin, yPosition);
  yPosition += 8;
  doc.text('This is an official document generated by the E-Matdaan voting system.', margin, yPosition);
};

const generateVoteCertificatePDF = (doc: any, certificate: VoteCertificate) => {
  const pageWidth = doc.internal.pageSize.width;
  const pageHeight = doc.internal.pageSize.height;
  const margin = 20;
  let yPosition = 40;

  // Certificate Border
  doc.setDrawColor(100, 100, 100);
  doc.setLineWidth(2);
  doc.rect(margin, margin, pageWidth - 2 * margin, pageHeight - 2 * margin);

  // Header
  doc.setFontSize(28);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(107, 33, 232); // Purple color
  doc.text('VOTE CERTIFICATE', pageWidth / 2, yPosition, { align: 'center' });
  yPosition += 20;

  // Subtitle
  doc.setFontSize(16);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(0, 0, 0);
  doc.text('Certificate of Participation', pageWidth / 2, yPosition, { align: 'center' });
  yPosition += 30;

  // Certificate ID
  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.text(`Certificate ID: ${certificate.certificateId}`, margin, yPosition);
  yPosition += 20;

  // Main content
  doc.setFontSize(14);
  doc.setFont('helvetica', 'normal');
  doc.text('This is to certify that:', margin, yPosition);
  yPosition += 20;

  doc.setFontSize(16);
  doc.setFont('helvetica', 'bold');
  doc.text(certificate.voterName, pageWidth / 2, yPosition, { align: 'center' });
  yPosition += 20;

  doc.setFontSize(14);
  doc.setFont('helvetica', 'normal');
  doc.text('has successfully cast their vote in the election:', margin, yPosition);
  yPosition += 20;

  doc.setFontSize(16);
  doc.setFont('helvetica', 'bold');
  doc.text(certificate.electionName, pageWidth / 2, yPosition, { align: 'center' });
  yPosition += 25;

  // Vote details
  doc.setFontSize(12);
  doc.setFont('helvetica', 'normal');
  doc.text(`Vote Cast For: ${certificate.candidateName}`, margin, yPosition);
  yPosition += 12;
  doc.text(`Vote Time: ${new Date(certificate.voteTime).toLocaleString()}`, margin, yPosition);
  yPosition += 12;
  doc.text(`Receipt ID: ${certificate.receiptId}`, margin, yPosition);
  yPosition += 12;
  doc.text(`Organization: ${certificate.organizationName}`, margin, yPosition);
  yPosition += 25;

  // Verification note
  doc.setFontSize(10);
  doc.setFont('helvetica', 'italic');
  doc.text('This certificate can be verified using the receipt ID at:', margin, yPosition);
  yPosition += 8;
  doc.setTextColor(107, 33, 232);
  doc.text(`${window.location.origin}/verify`, margin, yPosition);
  yPosition += 20;

  // Security features
  doc.setTextColor(0, 0, 0);
  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.text('Security Features:', margin, yPosition);
  yPosition += 8;
  doc.text('• Encrypted vote storage', margin + 10, yPosition);
  yPosition += 6;
  doc.text('• Digital signature verification', margin + 10, yPosition);
  yPosition += 6;
  doc.text('• Blockchain-verified integrity', margin + 10, yPosition);
  yPosition += 6;
  doc.text('• Zero-knowledge proof validation', margin + 10, yPosition);

  // Footer
  yPosition = pageHeight - 60;
  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  doc.text('Generated by E-Matdaan Voting System', pageWidth / 2, yPosition, { align: 'center' });
  yPosition += 8;
  doc.setFontSize(8);
  doc.setFont('helvetica', 'normal');
  doc.text(`Certificate generated on ${new Date().toLocaleString()}`, pageWidth / 2, yPosition, { align: 'center' });
};

// Generate election report
export const generateElectionReport = async (electionId: string): Promise<void> => {
  try {
    // Fetch election data
    const { data: election, error: electionError } = await supabase
      .from('elections')
      .select(`
        *,
        organization:organizations(name, logo_url),
        candidates(*)
      `)
      .eq('id', electionId)
      .single();

    if (electionError || !election) {
      throw new Error('Election not found');
    }

    // Fetch vote counts
    const { data: votes, error: votesError } = await supabase
      .from('votes')
      .select('candidate_id')
      .eq('election_id', electionId);

    if (votesError) {
      throw new Error('Failed to fetch votes');
    }

    // Calculate vote counts per candidate
    const voteCounts = new Map<string, number>();
    votes?.forEach(vote => {
      voteCounts.set(vote.candidate_id, (voteCounts.get(vote.candidate_id) || 0) + 1);
    });

    // Get total registered voters
    const { count: totalRegistered } = await supabase
      .from('auth_users')
      .select('id', { count: 'exact', head: true })
      .eq('organization_id', election.organization_id);

    const totalVotes = votes?.length || 0;
    const turnout = totalRegistered ? (totalVotes / totalRegistered) * 100 : 0;

    // Prepare candidates with vote counts
    const candidates = election.candidates?.map(candidate => {
      const votes = voteCounts.get(candidate.id) || 0;
      const percentage = totalVotes > 0 ? (votes / totalVotes) * 100 : 0;
      return {
        id: candidate.id,
        name: candidate.name,
        votes,
        percentage,
        position: 0 // Will be calculated below
      };
    }).sort((a, b) => b.votes - a.votes) || [];

    // Assign positions
    candidates.forEach((candidate, index) => {
      candidate.position = index + 1;
    });

    const report: ElectionReport = {
      id: election.id,
      name: election.name,
      description: election.description || '',
      startDate: election.start_time,
      endDate: election.end_time,
      totalVotes,
      totalRegistered: totalRegistered || 0,
      turnout,
      candidates,
      organization: {
        name: election.organization?.name || 'Unknown Organization',
        logo: election.organization?.logo_url
      },
      generatedAt: new Date().toISOString()
    };

    const filename = `election-report-${election.name.replace(/[^a-zA-Z0-9]/g, '-')}-${new Date().toISOString().split('T')[0]}.pdf`;
    
    await generatePDF({
      type: 'election_report',
      data: report
    }, filename);

  } catch (error) {
    console.error('Failed to generate election report:', error);
    throw error;
  }
};

// Generate vote certificate
export const generateVoteCertificate = async (voteId: string): Promise<void> => {
  try {
    // Fetch vote data
    const { data: vote, error: voteError } = await supabase
      .from('votes')
      .select(`
        *,
        election:elections(name),
        candidate:candidates(name),
        voter:auth_users(name),
        organization:organizations(name)
      `)
      .eq('id', voteId)
      .single();

    if (voteError || !vote) {
      throw new Error('Vote not found');
    }

    const certificate: VoteCertificate = {
      voterId: vote.voter_id,
      voterName: vote.voter?.name || 'Unknown Voter',
      electionName: vote.election?.name || 'Unknown Election',
      electionId: vote.election_id,
      voteTime: vote.created_at,
      receiptId: vote.id, // Using vote ID as receipt ID
      candidateName: vote.candidate?.name || 'Unknown Candidate',
      organizationName: vote.organization?.name || 'Unknown Organization',
      certificateId: `CERT-${vote.id.substring(0, 8).toUpperCase()}`
    };

    const filename = `vote-certificate-${certificate.certificateId}-${new Date().toISOString().split('T')[0]}.pdf`;
    
    await generatePDF({
      type: 'vote_certificate',
      data: certificate
    }, filename);

  } catch (error) {
    console.error('Failed to generate vote certificate:', error);
    throw error;
  }
};

// Generate comprehensive platform report
export const generatePlatformReport = async (organizationId: string, dateRange?: { start: string; end: string }): Promise<void> => {
  try {
    // Fetch organization data
    const { data: organization } = await supabase
      .from('organizations')
      .select('*')
      .eq('id', organizationId)
      .single();

    if (!organization) {
      throw new Error('Organization not found');
    }

    // Fetch all elections in date range
    let electionsQuery = supabase
      .from('elections')
      .select('*')
      .eq('organization_id', organizationId);

    if (dateRange) {
      electionsQuery = electionsQuery
        .gte('created_at', dateRange.start)
        .lte('created_at', dateRange.end);
    }

    const { data: elections } = await electionsQuery;

    // Fetch user statistics
    const { count: totalUsers } = await supabase
      .from('auth_users')
      .select('id', { count: 'exact', head: true })
      .eq('organization_id', organizationId);

    // Fetch total votes
    const { count: totalVotes } = await supabase
      .from('votes')
      .select('id', { count: 'exact', head: true });

    // Generate comprehensive report
    const report = {
      organization: organization.name,
      period: dateRange ? `${dateRange.start} to ${dateRange.end}` : 'All Time',
      totalElections: elections?.length || 0,
      totalUsers: totalUsers || 0,
      totalVotes: totalVotes || 0,
      elections: elections || [],
      generatedAt: new Date().toISOString()
    };

    const filename = `platform-report-${organization.name.replace(/[^a-zA-Z0-9]/g, '-')}-${new Date().toISOString().split('T')[0]}.pdf`;
    
    // For now, we'll create a simple text-based report
    // In production, you'd want a more sophisticated PDF layout
    await generatePDF({
      type: 'platform_report',
      data: report
    }, filename);

  } catch (error) {
    console.error('Failed to generate platform report:', error);
    throw error;
  }
}; 